basePath: /
definitions:
  resource.Resource:
    properties:
      name:
        type: string
      source_id:
        type: string
    type: object
  views.ResourceDto:
    properties:
      attributes:
        $ref: '#/definitions/resource.Resource'
        type: object
      id:
        type: string
      relationships:
        $ref: '#/definitions/views.relationships'
        type: object
      type:
        type: string
    type: object
  views.ResourceResponse:
    properties:
      data:
        items:
          $ref: '#/definitions/views.ResourceDto'
        type: array
    type: object
  views.genericData:
    properties:
      id:
        type: string
      type:
        enum:
        - foo
        - bar
        - baz
        type: string
    type: object
  views.parent:
    properties:
      data:
        $ref: '#/definitions/views.genericData'
        type: object
    type: object
  views.policies:
    properties:
      data:
        items:
          $ref: '#/definitions/views.genericData'
        type: array
    type: object
  views.relationships:
    properties:
      parent:
        $ref: '#/definitions/views.parent'
        type: object
      policies:
        $ref: '#/definitions/views.policies'
        type: object
    type: object
host: localhost:8080
info:
  contact:
    email: hmavani7@gmail.com
    name: API Support
  description: |-
    ### A domain agnostic permission management and querying API.

    At the most basic level the Sentinel API offers a way for consumers to manage access of application resources to other application resources through the use of policies.

    A simple example demonstrating this flexibility of this relationship could be:

    User (U1) has a policy (P1) granting read/write access to an account Resource (R)
    User (U2) has a policy (P2) granting read access to the same account Resource (R)

    The application can then query the api asking if (U1) can preform write access on (R) which will return True
    The application can also query the api asking if (U2) can perform write access on (R) which will return False

    More advanced capabilities include:
    * Inheritance - Resource access granted to a parent permits the same access to all children
    * Invitations - This model allows users having `with_grant` permissions to invite other users to join in a self-service way
    * Context - Users with multiple policies can have differing permission. The api permits the caller to specify context when performing permission checks.

    ## ERD

    ![Image](https://www.lucidchart.com/publicSegments/view/e66a76a3-8114-4b1c-9104-765f307c7869/image.png)

    ## Resources
    ---
    Simply stated a resource represents the nouns in your application. Resources are polymorphic and might represent users,
    accounts, or any application specific entity requiring gated access.

    Resources are granted access to other resources through Policies. It is possible for a resource to be the
    `principal` in once policy while simultaneously a `target_resource` in another policy.


    _See definitions below for further explanation of principals and target_resources._


    Resource may be owned by other resources. Resource inheritance will help reduce redundant permissions to similar resources
    if the principal has the same level of access to a class of resource. E.g. System Admins can read/write all accounts.

    **Precedence is determined by path length.** - In the event a resource has two policies with conflicting permission
    to a resource, the path with the shortest distance to the resource is preferred.

    #### Example:
    ---
    **Given:**

    The following resources exist - Parent Resource (PR), Child Resource (CR), Principal (P)

    **AND**

    The following Policies exist - Policy (P1), Policy (P2)

    **AND**

    Parent Resource (PR) owns Child Resource (CR)

    **AND**

    Principal (P) has a policy (P1) explicitly denying a permission, say "read", to (PR)

    **AND**

    Principal (P) has a policy (P2) allowing the same permission, "read", to (CR)

    **Conclusion:**
    (P) can not read (PR)
    (P) can read (CR)

    In the event there are two policies from a principal directly to a resource with conflicting permission, the permission
    check will fail close and access will be denied.

    #### Example:
    ---
    **Given:**

    The following resources exist - Child Resource (R), Principal (P)

    **AND**

    The following Policies exist - Policy (P1), Policy (P2)

    **AND**

    Principal (P) has a policy (P1) explicitly denying a permission, say "read", to (R)

    **AND**

    Principal (P) has a policy (P2) allowing the same permission, "read", to (R)

    **Conclusion:**
    (P) can not read (R)

    ## Policies

    ---
    Policies `allow` or `deny` permissions to principals on target resources. A single policy can be granted to zero or
    more principals and affect zero or more target resources.

    A policy contains zero or more permissions to target resources. A permission is always scoped to a single target resource within the policy.
    However, it is possible to grant the same permission to multiple target resources, or grant multiple permissions to
    one target resource within the context of a single policy.

    Each grant of a policy to a principal contains a `with_grant` boolean allowing the aforementioned principal to
    propagate their permissions to additional principals if the `with_grant` option has been set to `true`.
    By default `with_grant=false`.

    ## Permissions
    ---
    A permission defines access to perform an action between a Policy and a Resource.
    Permissions take simply a `name` and whether the permission is `permitted`.
    The `name` is used to determine a principal\'s authorization to a target resource.

    Permission Rules:
    * A permission can have `permitted: "allow"` which grants all `principals` of the policy access to the `target_resource` for that permission.
    * A permission can have `permitted: "deny"` which prevents all `principals` of the policy from performing the permission action the `target_resource` for that permission.
    * A permission can be `revoked` which will remove the `allow` or `deny` constraint. Access may then be based on the inheritance rules described above.
    * There is a unique constraint on the `(Policy.id, Permission.name, Resource.id)` tuple.

    ### Definitions
    |Entity|Definition|
    |------|----------|
    |Resource|Any noun in your application. Resources (principals) access other Resources (target resource) through policies.|
    |Policy|A named collection of permissions. Policies are granted to resources (principals) and grant or deny access to affect resources (target resources) through permissions.|
    |Permission|An explicit allowance or refusal of a resource (principal) to perform an action on a resource (target resource).|
    |Principal|In the context of a Policy the principal refers to the resource which has been granted access to make use of the policy.|
    |Target Resource|In the context of a Policy a target resource is any and all resources which the policy allows or denies access through Permissions.|

    ### Getting Started
    Review the [Getting Started Guide](http://localhost:3000/documentation/GettingStarted.md) for minimal setup instructions
  license: {}
  title: Sentinel API
  version: 0.1.0
paths:
  /resources:
    get:
      consumes:
      - application/json
      description: Get all the nodes present in the graph
      produces:
      - application/json
      responses:
        "200":
          description: ok
          schema:
            $ref: '#/definitions/views.ResourceResponse'
      summary: Get all the resources
swagger: "2.0"
